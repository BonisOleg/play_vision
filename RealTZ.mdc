---
alwaysApply: true
---
## 2. МОДЕЛІ БАЗИ ДАНИХ

### 2.1 Додаток accounts
```python
# accounts/models.py

class User(AbstractUser):
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=20, blank=True)
    is_email_verified = models.BooleanField(default=False)
    is_phone_verified = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []

class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    birth_date = models.DateField(null=True, blank=True)
    avatar = models.ImageField(upload_to='avatars/', blank=True)
    profession = models.CharField(max_length=100, blank=True)
    interests = models.ManyToManyField('core.Interest', blank=True)
    completed_survey = models.BooleanField(default=False)
    survey_completed_at = models.DateTimeField(null=True, blank=True)

class SocialAccount(models.Model):
    PROVIDER_CHOICES = [
        ('google', 'Google'),
        ('telegram', 'Telegram'),
        ('tiktok', 'TikTok'),
    ]
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    provider = models.CharField(max_length=20, choices=PROVIDER_CHOICES)
    provider_id = models.CharField(max_length=100)
    extra_data = models.JSONField(default=dict)

class VerificationCode(models.Model):
    CODE_TYPES = [
        ('email', 'Email Verification'),
        ('phone', 'Phone Verification'),
        ('password_reset', 'Password Reset'),
    ]
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    code = models.CharField(max_length=6)
    code_type = models.CharField(max_length=20, choices=CODE_TYPES)
    created_at = models.DateTimeField(auto_now_add=True)
    used_at = models.DateTimeField(null=True, blank=True)
    expires_at = models.DateTimeField()
    
    @property
    def is_expired(self):
        return timezone.now() > self.expires_at
```

### 2.2 Додаток courses
```python
# courses/models.py

class Category(models.Model):
    name = models.CharField(max_length=100)
    slug = models.SlugField(unique=True)
    description = models.TextField(blank=True)
    icon = models.CharField(max_length=50, blank=True)  # CSS class або SVG
    is_active = models.BooleanField(default=True)

class Tag(models.Model):
    name = models.CharField(max_length=50, unique=True)
    slug = models.SlugField(unique=True)

class Course(models.Model):
    DIFFICULTY_CHOICES = [
        ('beginner', 'Початковий'),
        ('intermediate', 'Середній'),
        ('advanced', 'Експертний'),
    ]
    
    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)
    description = models.TextField()
    short_description = models.CharField(max_length=300)
    category = models.ForeignKey(Category, on_delete=models.CASCADE)
    tags = models.ManyToManyField(Tag, blank=True)
    difficulty = models.CharField(max_length=20, choices=DIFFICULTY_CHOICES)
    duration_minutes = models.PositiveIntegerField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    
    # Доступ та контроль
    is_featured = models.BooleanField(default=False)
    is_free = models.BooleanField(default=False)
    requires_subscription = models.BooleanField(default=True)
    subscription_tiers = models.JSONField(default=list)  # ['tier1', 'tier2']
    
    # Метадані
    thumbnail = models.ImageField(upload_to='course_thumbnails/')
    preview_video = models.FileField(upload_to='course_previews/', blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # Статистика
    view_count = models.PositiveIntegerField(default=0)
    enrollment_count = models.PositiveIntegerField(default=0)
    rating = models.DecimalField(max_digits=3, decimal_places=2, default=0)

class CourseLesson(models.Model):
    CONTENT_TYPES = [
        ('video', 'Відео'),
        ('pdf', 'PDF'),
        ('article', 'Стаття'),
        ('quiz', 'Тест'),
    ]
    
    course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name='lessons')
    title = models.CharField(max_length=200)
    slug = models.SlugField()
    content_type = models.CharField(max_length=20, choices=CONTENT_TYPES)
    order = models.PositiveIntegerField()
    
    # Контент
    video_file = models.FileField(upload_to='lessons/videos/', blank=True)
    pdf_file = models.FileField(upload_to='lessons/pdfs/', blank=True)
    article_content = models.TextField(blank=True)
    
    # Метадані
    duration_seconds = models.PositiveIntegerField(default=0)
    is_preview = models.BooleanField(default=False)  # Доступний без підписки
    
    class Meta:
        unique_together = ['course', 'slug']
        ordering = ['order']

class UserCourseProgress(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    course = models.ForeignKey(Course, on_delete=models.CASCADE)
    lessons_completed = models.ManyToManyField(CourseLesson, blank=True)
    progress_percentage = models.DecimalField(max_digits=5, decimal_places=2, default=0)
    started_at = models.DateTimeField(auto_now_add=True)
    last_accessed = models.DateTimeField(auto_now=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        unique_together = ['user', 'course']

class Favorite(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    course = models.ForeignKey(Course, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        unique_together = ['user', 'course']
```

### 2.3 Додаток events
```python
# events/models.py

class Event(models.Model):
    EVENT_TYPES = [
        ('forum_professionals', 'Форум футбольних фахівців'),
        ('forum_parents', 'Форум футбольних батьків'),
        ('internship', 'Стажування в професійних клубах'),
        ('seminar', 'Практичні семінари і хакатони'),
        ('psychology', 'Воркшопи зі спортивної психології'),
        ('selection_camp', 'Селекційні табори'),
        ('webinar', 'Онлайн-теорії і вебінари'),
    ]
    
    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)
    description = models.TextField()
    event_type = models.CharField(max_length=30, choices=EVENT_TYPES)
    
    # Дата та місце
    start_datetime = models.DateTimeField()
    end_datetime = models.DateTimeField()
    location = models.CharField(max_length=200, blank=True)  # Або онлайн
    zoom_link = models.URLField(blank=True)
    
    # Білети та ціни
    ticket_price = models.DecimalField(max_digits=10, decimal_places=2)
    max_attendees = models.PositiveIntegerField()
    tickets_sold = models.PositiveIntegerField(default=0)
    
    # Метадані
    image = models.ImageField(upload_to='events/')
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    @property
    def available_tickets(self):
        return self.max_attendees - self.tickets_sold
        
    @property
    def is_sold_out(self):
        return self.tickets_sold >= self.max_attendees

class EventSpeaker(models.Model):
    event = models.ForeignKey(Event, on_delete=models.CASCADE, related_name='speakers')
    name = models.CharField(max_length=100)
    bio = models.TextField()
    photo = models.ImageField(upload_to='speakers/')
    position = models.CharField(max_length=100)

class EventTicket(models.Model):
    TICKET_STATUS = [
        ('pending', 'Очікує оплати'),
        ('paid', 'Оплачено'),
        ('used', 'Використано'),
        ('refunded', 'Повернено'),
    ]
    
    event = models.ForeignKey(Event, on_delete=models.CASCADE)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    ticket_number = models.CharField(max_length=20, unique=True)
    status = models.CharField(max_length=20, choices=TICKET_STATUS, default='pending')
    qr_code = models.CharField(max_length=100, blank=True)
    
    # Оплата
    paid_with_balance = models.BooleanField(default=False)  # Pro-Vision баланс
    payment = models.ForeignKey('payments.Payment', on_delete=models.SET_NULL, null=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    used_at = models.DateTimeField(null=True, blank=True)
```

### 2.4 Додаток payments
```python
# payments/models.py

class SubscriptionPlan(models.Model):
    PLAN_TYPES = [
        ('monthly', 'Місячна'),
        ('quarterly', '3 місяці'),
        ('yearly', 'Річна'),
    ]
    
    name = models.CharField(max_length=100)
    plan_type = models.CharField(max_length=20, choices=PLAN_TYPES)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    duration_days = models.PositiveIntegerField()
    
    # Особливості плану
    features = models.JSONField(default=list)  # ['Доступ до всіх курсів', 'Підтримка 24/7']
    event_tickets_balance = models.PositiveIntegerField(default=0)  # Для Pro-Vision
    is_pro_vision = models.BooleanField(default=False)
    
    # Відображення
    is_popular = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    display_order = models.PositiveIntegerField(default=0)

class UserSubscription(models.Model):
    SUBSCRIPTION_STATUS = [
        ('active', 'Активна'),
        ('expired', 'Закінчена'),
        ('cancelled', 'Скасована'),
        ('pending', 'Очікує оплати'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    plan = models.ForeignKey(SubscriptionPlan, on_delete=models.CASCADE)
    status = models.CharField(max_length=20, choices=SUBSCRIPTION_STATUS)
    
    # Дати
    start_date = models.DateTimeField()
    end_date = models.DateTimeField()
    auto_renew = models.BooleanField(default=True)
    
    # Платіжні дані
    stripe_subscription_id = models.CharField(max_length=100, blank=True)
    payment = models.ForeignKey('Payment', on_delete=models.SET_NULL, null=True)
    
    # Баланс квитків для Pro-Vision
    tickets_balance = models.PositiveIntegerField(default=0)
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    @property
    def is_active(self):
        return (self.status == 'active' and 
                self.end_date > timezone.now())

class Payment(models.Model):
    PAYMENT_STATUS = [
        ('pending', 'Очікує'),
        ('processing', 'Обробляється'),
        ('completed', 'Завершено'),
        ('failed', 'Помилка'),
        ('refunded', 'Повернено'),
    ]
    
    PAYMENT_TYPE = [
        ('subscription', 'Підписка'),
        ('course', 'Курс'),
        ('event_ticket', 'Квиток на івент'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    currency = models.CharField(max_length=3, default='USD')
    payment_type = models.CharField(max_length=20, choices=PAYMENT_TYPE)
    status = models.CharField(max_length=20, choices=PAYMENT_STATUS, default='pending')
    
    # Платіжний провайдер
    stripe_payment_intent_id = models.CharField(max_length=100, blank=True)
    provider_response = models.JSONField(default=dict)
    
    # Метадані
    created_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    
class Coupon(models.Model):
    DISCOUNT_TYPE = [
        ('percentage', 'Відсоток'),
        ('fixed', 'Фіксована сума'),
    ]
    
    code = models.CharField(max_length=50, unique=True)
    discount_type = models.CharField(max_length=20, choices=DISCOUNT_TYPE)
    discount_value = models.DecimalField(max_digits=10, decimal_places=2)
    
    # Обмеження
    min_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    max_uses = models.PositiveIntegerField(null=True, blank=True)
    used_count = models.PositiveIntegerField(default=0)
    
    # Дати
    valid_from = models.DateTimeField()
    valid_until = models.DateTimeField()
    
    is_active = models.BooleanField(default=True)
    
    @property
    def is_valid(self):
        now = timezone.now()
        return (self.is_active and 
                self.valid_from <= now <= self.valid_until and
                (self.max_uses is None or self.used_count < self.max_uses))

class LoyaltyProgram(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    points = models.PositiveIntegerField(default=0)
    tier = models.CharField(max_length=20, default='Bronze')  # Bronze, Silver, Gold, Platinum
    lifetime_spent = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    
    def get_discount_percentage(self):
        tiers = {
            'Bronze': 0,
            'Silver': 5,
            'Gold': 10,
            'Platinum': 15,
        }
        return tiers.get(self.tier, 0)
```

---

## 3. ОСНОВНІ VIEWS ТА ЛОГІКА

### 3.1 Accounts Views
```python
# accounts/views.py

class CustomRegisterView(CreateView):
    model = User
    form_class = CustomUserCreationForm
    template_name = 'auth/register.html'
    success_url = '/account/'
    
    def form_valid(self, form):
        response = super().form_valid(form)
        # Створення профілю
        UserProfile.objects.create(user=self.object)
        # Відправка верифікаційного коду
        send_verification_code.delay(self.object.id, 'email')
        # Push-нотифікація через 5 хвилин
        send_survey_reminder.apply_async(
            args=[self.object.id], 
            countdown=300  # 5 хвилин
        )
        return response

class ProfileUpdateView(LoginRequiredMixin, UpdateView):
    model = UserProfile
    fields = ['first_name', 'last_name', 'birth_date', 'avatar', 'profession', 'interests']
    template_name = 'account/profile.html'
    
    def get_object(self):
        return self.request.user.userprofile
    
    def form_valid(self, form):
        if not form.instance.completed_survey:
            form.instance.completed_survey = True
            form.instance.survey_completed_at = timezone.now()
            # Нарахування бонусу за заповнення анкети
            give_survey_bonus.delay(self.request.user.id)
        return super().form_valid(form)

class AccountDashboardView(LoginRequiredMixin, TemplateView):
    template_name = 'account/dashboard.html'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        user = self.request.user
        
        # Активна підписка
        context['subscription'] = user.usersubscription_set.filter(
            status='active'
        ).first()
        
        # Останні курси
        context['recent_courses'] = user.usercourse progress_set.select_related(
            'course'
        ).order_by('-last_accessed')[:5]
        
        # Upcoming івенти
        context['upcoming_events'] = user.eventticket_set.filter(
            event__start_datetime__gte=timezone.now(),
            status='paid'
        ).select_related('event')[:3]
        
        return context
```

### 3.2 Courses Views
```python
# courses/views.py

class CourseListView(ListView):
    model = Course
    template_name = 'hub/course_list.html'
    context_object_name = 'courses'
    paginate_by = 12
    
    def get_queryset(self):
        queryset = Course.objects.select_related('category').prefetch_related('tags')
        
        # Фільтри
        category = self.request.GET.get('category')
        if category:
            queryset = queryset.filter(category__slug=category)
            
        difficulty = self.request.GET.get('difficulty')
        if difficulty:
            queryset = queryset.filter(difficulty=difficulty)
            
        # Пошук
        search = self.request.GET.get('q')
        if search:
            queryset = queryset.filter(
                Q(title__icontains=search) |
                Q(description__icontains=search) |
                Q(tags__name__icontains=search)
            ).distinct()
        
        return queryset.order_by('-created_at')

class CourseDetailView(DetailView):
    model = Course
    template_name = 'hub/course_detail.html'
    context_object_name = 'course'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        course = self.object
        user = self.request.user
        
        # Перевірка доступу
        if user.is_authenticated:
            context['has_access'] = user.has_course_access(course)
            context['is_favorite'] = user.favorite_set.filter(course=course).exists()
            context['progress'] = user.usercourseprogress_set.filter(course=course).first()
        else:
            context['has_access'] = False
            
        # Рекомендовані курси
        context['recommended_courses'] = get_recommended_courses(course, user)
        
        return context

def get_recommended_courses(course, user, limit=4):
    """Collaborative filtering для рекомендацій"""
    # Спрощена логіка - курси з тією ж категорією та тегами
    return Course.objects.filter(
        Q(category=course.category) | Q(tags__in=course.tags.all())
    ).exclude(id=course.id).distinct()[:limit]
```

---

## 4. CELERY TASKS

### 4.1 Email та SMS задачі
```python
# core/tasks.py

@shared_task
def send_verification_code(user_id, code_type):
    """Відправка верифікаційного коду"""
    user = User.objects.get(id=user_id)
    code = generate_verification_code()
    
    VerificationCode.objects.create(
        user=user,
        code=code,
        code_type=code_type,
        expires_at=timezone.now() + timedelta(minutes=15)
    )
    
    if code_type == 'email':
        send_email_code(user.email, code)
    elif code_type == 'phone':
        send_sms_code(user.phone, code)

@shared_task
def send_survey_reminder(user_id):
    """Push-нотифікація через 5 хвилин після реєстрації"""
    try:
        user = User.objects.get(id=user_id)
        if not user.userprofile.completed_survey:
            # Відправка push-повідомлення або email
            send_push_notification(
                user,
                "Заповни анкету та отримай бонус!",
                "Персональні рекомендації чекають на тебе"
            )
    except User.DoesNotExist:
        pass

@shared_task
def give_survey_bonus(user_id):
    """Нарахування бонусу за заповнення анкети"""
    user = User.objects.get(id=user_id)
    # Логіка нарахування бонусу (знижка, безкоштовний курс, тощо)
    create_coupon_for_user(user, 'SURVEY_BONUS', 20)  # 20% знижка
```

### 4.2 Платіжні задачі
```python
# payments/tasks.py

@shared_task
def process_subscription_renewal(subscription_id):
    """Автоматичне поновлення підписки"""
    subscription = UserSubscription.objects.get(id=subscription_id)
    
    if subscription.auto_renew and subscription.is_active:
        try:
            # Спроба списання через Stripe
            payment_intent = stripe.PaymentIntent.create(
                amount=int(subscription.plan.price * 100),
                currency='usd',
                customer=subscription.user.stripe_customer_id,
                payment_method=subscription.user.default_payment_method,
                confirm=True
            )
            
            if payment_intent.status == 'succeeded':
                # Продовження підписки
                subscription.end_date += timedelta(days=subscription.plan.duration_days)
                subscription.save()
                
                # Відправка підтвердження
                send_subscription_renewed_email.delay(subscription.user.id)
            else:
                # Помилка платежу
                send_payment_failed_email.delay(subscription.user.id)
                
        except Exception as e:
            logger.error(f"Subscription renewal failed: {e}")

@shared_task
def send_subscription_renewed_email(user_id):
    """Email про поновлення підписки"""
    user = User.objects.get(id=user_id)
    send_email(
        user.email,
        'Підписка поновлена',
        'subscription_renewed.html',
        {'user': user}
    )
```

---

## 5. MIDDLEWARE ТА УТИЛІТИ

### 5.1 PaywallMiddleware
```python
# core/middleware.py

class PaywallMiddleware:
    """Автоматична перевірка доступу до захищеного контенту"""
    
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)
        
        # Перевірка доступу тільки для курсів
        if request.path.startswith('/hub/course/'):
            course_slug = request.path.split('/')[-2]
            try:
                course = Course.objects.get(slug=course_slug)
                if request.user.is_authenticated:
                    has_access = request.user.has_course_access(course)
                    request.course_access = has_access
                else:
                    request.course_access = False
            except Course.DoesNotExist:
                pass
                
        return response

class AnalyticsMiddleware:
    """Збір внутрішньої аналітики"""
    
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        start_time = time.time()
        response = self.get_response(request)
        
        # Логування тільки для важливих сторінок
        if any(path in request.path for path in ['/hub/', '/events/', '/checkout/']):
            duration = time.time() - start_time
            log_page_view.delay(
                request.user.id if request.user.is_authenticated else None,
                request.path,
                duration,
                response.status_code
            )
            
        return response
```

### 5.2 Утиліти доступу
```python
# accounts/utils.py

def user_has_course_access(user, course):
    """Перевірка доступу користувача до курсу"""
    if not user.is_authenticated:
        return False
    
    # Безкоштовні курси
    if course.is_free:
        return True
    
    # Придбаний окремо
    if user.purchased_courses.filter(id=course.id).exists():
        return True
    
    # Доступ через підписку
    if course.requires_subscription:
        subscription = user.usersubscription_set.filter(status='active').first()
        if subscription and subscription.is_active:
            # Перевірка рівня підписки
            if subscription.plan.plan_type in course.subscription_tiers:
                return True
    
    return False

# Додаємо метод до User моделі
User.add_to_class('has_course_access', user_has_course_access)
```

---

## 6. FORMS ТА ВАЛІДАЦІЯ

### 6.1 Авторизація та реєстрація
```python
# accounts/forms.py

class CustomUserCreationForm(UserCreationForm):
    email = forms.EmailField(required=True)
    phone = forms.CharField(max_length=20, required=False)
    agree_terms = forms.BooleanField(required=True)
    agree_newsletter = forms.BooleanField(required=False)
    
    class Meta:
        model = User
        fields = ('email', 'phone', 'password1', 'password2')
    
    def clean_email(self):
        email = self.cleaned_data['email']
        if User.objects.filter(email=email).exists():
            raise forms.ValidationError("Користувач з таким email вже існує")
        return email

class ProfileForm(forms.ModelForm):
    class Meta:
        model = UserProfile
        fields = ['first_name', 'last_name', 'birth_date', 'avatar', 'profession', 'interests']
        widgets = {
            'birth_date': forms.DateInput(attrs={'type': 'date'}),
            'interests': forms.CheckboxSelectMultiple(),
        }
```

### 6.2 Платежі та підписки
```python
# payments/forms.py

class CheckoutForm(forms.Form):
    first_name = forms.CharField(max_length=50)
    last_name = forms.CharField(max_length=50)
    email = forms.EmailField()
    coupon_code = forms.CharField(max_length=50, required=False)
    agree_terms = forms.BooleanField(required=True)
    
    def clean_coupon_code(self):
        code = self.cleaned_data.get('coupon_code')
        if code:
            try:
                coupon = Coupon.objects.get(code=code.upper())
                if not coupon.is_valid:
                    raise forms.ValidationError("Промокод недійсний або закінчився")
                return coupon
            except Coupon.DoesNotExist:
                raise forms.ValidationError("Промокод не знайдено")
        return None

class CouponValidationForm(forms.Form):
    """AJAX валідація промокоду"""
    code = forms.CharField(max_length=50)
    cart_total = forms.DecimalField(max_digits=10, decimal_places=2)
    
    def clean(self):
        cleaned_data = super().clean()
        code = cleaned_data.get('code')
        cart_total = cleaned_data.get('cart_total')
        
        if code and cart_total:
            try:
                coupon = Coupon.objects.get(code=code.upper())
                if not coupon.is_valid:
                    raise forms.ValidationError("Промокод недійсний")
                if cart_total < coupon.min_amount:
                    raise forms.ValidationError(f"Мінімальна сума замовлення: {coupon.min_amount} USD")
                cleaned_data['coupon'] = coupon
            except Coupon.DoesNotExist:
                raise forms.ValidationError("Промокод не знайдено")
        
        return cleaned_data
```

---

## 7. API ENDPOINTS

### 7.1 Кошик API
```python
# core/api.py

from rest_framework.views import APIView
from rest_framework.response import Response

class CartAPIView(APIView):
    """CRUD операції з кошиком"""
    
    def post(self, request):
        """Додавання товару в кошик"""
        course_id = request.data.get('course_id')
        try:
            course = Course.objects.get(id=course_id)
            cart = get_or_create_cart(request)
            cart.add_course(course)
            return Response({
                'success': True,
                'cart_count': cart.total_items,
                'message': f'Курс "{course.title}" додано в кошик'
            })
        except Course.DoesNotExist:
            return Response({'success': False, 'error': 'Курс не знайдено'})
    
    def delete(self, request):
        """Видалення товару з кошика"""
        course_id = request.data.get('course_id')
        cart = get_or_create_cart(request)
        cart.remove_course(course_id)
        return Response({
            'success': True,
            'cart_count': cart.total_items
        })

class SearchAutocompleteAPIView(APIView):
    """Автокомпліт для пошуку"""
    
    def get(self, request):
        query = request.GET.get('q', '')
        if len(query) < 2:
            return Response([])
        
        courses = Course.objects.filter(
            title__icontains=query
        ).values('title', 'slug')[:10]
        
        return Response(list(courses))

def get_or_create_cart(request):
    """Отримання кошика для користувача або сесії"""
    if request.user.is_authenticated:
        cart, created = Cart.objects.get_or_create(user=request.user)
    else:
        # Session-based cart
        cart_id = request.session.get('cart_id')
        if cart_id:
            try:
                cart = Cart.objects.get(id=cart_id, user=None)
            except Cart.DoesNotExist:
                cart = Cart.objects.create()
                request.session['cart_id'] = cart.id
        else:
            cart = Cart.objects.create()
            request.session['cart_id'] = cart.id
    return cart
```

---

## 8. НАЛАШТУВАННЯ ТА КОНФІГУРАЦІЯ

### 8.1 Base Settings
```python
# settings/base.py

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    # Third party
    'rest_framework',
    'corsheaders',
    'django_ratelimit',
    'imagekit',
    'celery',
    'stripe',
    
    # Local apps
    'apps.accounts',
    'apps.courses',
    'apps.events',
    'apps.payments',
    'apps.analytics',
    'apps.core',
]

AUTH_USER_MODEL = 'accounts.User'

# Celery Configuration
CELERY_BROKER_URL = 'redis://localhost:6379/0'
CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'

# Email Configuration
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.gmail.com'
EMAIL_PORT = 587
EMAIL_USE_TLS = True

# Media Files
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# Static Files
STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

# Security
SECURE_SSL_REDIRECT = True
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
```

---

Це основа backend логіки. Далі створю бібліотеку підключень для frontend.